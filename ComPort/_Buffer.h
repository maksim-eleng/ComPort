#pragma once
/*******************************************************
	Класс для организации кольцевого буфера



*/

#include <string>
#include <cassert>
//#include <stdint.h>
#include "SysConst.h"

#include <iostream>

#define bufResultIsNG		-1
#define bufResultNG			-1

// minimum buffer size. default for dynamic data
#define MIN_BUFFER_SIZE	512

#ifndef DISABLE_INTERRUPT
#define DISABLE_INTERRUPT
#endif
#ifndef ENABLE_INTERRUPT
#define ENABLE_INTERRUPT
#endif


class Buffer
{
/*****			PUBLIC SECTION			 ******/
/**********************************************/
/*****	  Constructors & destructors	 ******/
/**********************************************/
public:

	/****************************************************
	*****	Конструктор создания	*********************
	При вызове конструктора по умолчанию создается буфер
	с размером MIN_BUFFER_SIZE
	При создании объекта счетчик объектов ++m_objectCounter
	Вход:	char* _buf - указатель на уже имеющийся массив
			char* _buf = 0 - ОП под буфер будет выделена динамически (по умолчанию)
			int _size - размер массива для динамического выделения (=0 по умолчанию)
	Создание объекта:
	Buffer buf;	Buffer buf(NULL);	- с динамическим выделением, размер MIN_BUFFER_SIZE байт 
	Buffer buf(NULL, 100);			- с динамическим выделением, размер 100 байт 
	Buffer buf(buffer, sizeof(buffer));		- передача имени внешнего буфера, размер 100 байт
	*****************************************************/
	Buffer(char* _buf = 0, int size = MIN_BUFFER_SIZE);
	// Copyer constructor - not for use 
 	Buffer(const Buffer& buf) = delete;
	// Destructor 
	/****************************************************
	*****		Destructor			*********************
	Если была выделена ОП динамически - освобождает
	*****************************************************/
	~Buffer();

	/***************	Put section		**************/
	/*************************************************/

	/****************************************************
	*****	Кладет символ в буфер 
	*****************************************************/
	int put(const char byte);
	/****************************************************
	*****	Кладет строку в c_style в буфер		*********
	Если строка начинается с '\0' - пропускается
	Символ завершения строки переписывается, если !='\0'
	Вход:	const char* str - может быть buf[] или "Hellow"
			char StrEndSymbol - признак конца строки (по умолчанию '\0')
	Выход:	индекс буфера для следующей записи или 
					bufResultIsNG (=-1) - не успешно (при этом индексы буфера возвращаются в исходное состояние)
	Вызов:	buf.put("Hellow\n", '\n');	или		buf.put("Hellow");
	*****************************************************/
	int put(const char* str, char StrEndSymbol='\0');
	/****************************************************
	*****	Кладет строку в std::string в буфер		*****
	Если строка начинается с '\0' - пропускается
	Символ завершения строки переписывается, если !='\0'
	Вход:	std::string& str - class std::string
			char StrEndSymbol - признак конца строки (по умолчанию '\0')
	Выход:	индекс буфера для следующей записи или
					bufResultIsNG (=-1) - не успешно (при этом индексы буфера возвращаются в исходное состояние)
	*****************************************************/
	int put(std::string& str, char StrEndSymbol = '\0');

	/************	Get section		******************/
	/*************************************************/

	/****************************************************
	*****	Return buffer;s size in byte	****************/
	int getBufSize()	const { return m_size; }

	/****************************************************
	*****	Берет из буфера байт (char), если буфер не пустой	*****
	Выход:	байт или bufResultIsNG (=-1), если буфер пустой
	*****************************************************/
	char get();
	/****************************************************
	*****	Берет из буфера байт (char) по внешнему индексу, 
	если не достигли головы буфера	*****
	Не изменяет переменные буфера
	Вход:	int& index - & на внешнюю переменную, инкрементируется по кольцу
	Выход:	байт или bufResultIsNG (=-1), если достигли головы буфера
	*****************************************************/
	char get(int& index);
	/****************************************************
	*****	Берет из буфера строку с strEndSymbol включительно.
	Строка-приеммник - в cstyle
	В сулчае неполного чтения строки (достигнут конец буфера до чтения 
	strEndSymbol или приеммник был ранее переполнен) - cтрока-приеммник завершается '\0',
	возвращается bufResultNG
	Вход:	char* str - cтрока-приеммник
			int sizeStr - размер строки
			char strEndSymbol - символ конца строки (='\0' по умолчанию)
	Выход:	индекс буфера для следующего чтения или
			bufResultNG, если чтение неудачно
	Вызов:	index = buf.get(buffer, sizeof(buffer), '\n');
	*****************************************************/
	int get(char* str, int sizeStr, char strEndSymbol = '\0');
	/****************************************************
	*****	Берет из буфера строку с strEndSymbol включительно.
	Строка-приеммник - std::string
	В сулчае неполного чтения строки (достигнут конец буфера до чтения
	strEndSymbol) - возвращается bufResultNG
	Вход:	string& str - cтрока-приеммник
			char strEndSymbol - символ конца строки (='\0' по умолчанию)
	Выход:	индекс буфера для следующего чтения или
			bufResultNG, если чтение неудачно
	Вызов:	index = buf.get(string, '\n');
	*****************************************************/
	int get(std::string& str, char strEndSymbol = '\0');
	/* Get buffer index for Write operation*/
	inline int getIndexForWrite() const	{ return m_front; }
	/* Get buffer index for Read operation*/
	inline int getIndexForRead() const	{ return m_end; }
	/* Get number of created buffers */
	inline static int getObjectCounter() { return m_objectCounter;}
	/* Chech buffer. Return true, if not enpty*/
	inline bool checkIsNotEpty() { return (bool)m_len; }

	/****   Operators ovrflow	******/

	/*	Группа operator= - то же что и put(), но с 
		Предварительной очисткой буфера */
	int operator=(const char byte);
	int operator=(const char* str);
	int operator=(std::string& str);
	// копирование объектов запрещено, в том числе через
	// конструктор копирования
	Buffer& operator=(const Buffer& buf) = delete;
	/*	Группа operator+= - аналогично с put()	*/
	int operator+=(const char byte);
	int operator+=(const char* str);
	int operator+=(std::string& str);
	// берет байт из буфера по индексу
	char operator[](int index);

	/**********	 Other function		******************/
	/*************************************************/

	/****************************************************
	*****	Поиск символа до головы буфера (непрочитанная область).
	Не меняет переменные буфера.
	Вход:	char byte - символ для поиска
	Выход:	индекс буфера для найденнго символа или 
			bufResultNG (=-1) - символ не найден
	Вызов:	index = buf.search('\n');
	*****************************************************/
	int search(char byte);
	/****************************************************
	*****	Поиск строки в буфере до головы буфера (непрочитанная область).
	Поиск ведется до '\0' в входной строке str, начиная с хвоста,
	т.е. в области необработанных данных. 
	Не меняет переменные буфера.
	Вход:	const char* str - строка для поиска
			bool isReturnIndAfterStr - определяет что возвращает ф-я: 
				false - индекс начала строки str в буфере
				true - индекс буфера после найденной строки в буфере 
				По умолчанию = false
			int pStartInBuf - начальный индекс поиска. По умолчанию =0 и становится на начало 
				необработанных данных (на хвост буфера)
	Выход:	индекс буфера начала найденной строки (если isReturnIndAfterStr=false) или
			индекс буфера после найденной строки в буфере (если isReturnIndAfterStr=true) или
			bufResultNG (=-1) - строка не найдена
	Вызов:	index = buf.search("Hellow");	indexAfter = buf.search("Hellow", true);
	*****************************************************/
	int search(const char* str, bool isReturnIndAfterStr = false, int pStartInBuf = 0 );
	/****************************************************
	*****	Прыжок по буферу с изменением переменных буфера
	Поддерживает: 
		безусловный прыжок - если isUnconditionalJump = 1 (по умолчанию). 
			numSteps - новых хвоста буфера. Должен принадлежать области необработанных данных.
		Последовательный прыжок - isUnconditionalJump = 0
			numSteps определяет кол-во шагов изменения хвоста буфера (выполняется
			по кольцу). При достижении головы буфера - возврат в исходное состояние 
			и ф-я возвращает bufResultNG (=-1)
	Вход:	int numSteps - новое значение хвоста буфера (для безусловного прыжка).
				Должен принадлежать области необработанных данных.
				или кол-во шагов для изменения (знак определяет направление)
			bool isUnconditionalJump - определяет метод прыжка: безусловный (по умолчанмю)
				или последовательный
	Выход:	новое значение хвоста буфера bufResultNG (=-1) - прыжок не выполнен
	Вызов:	index = buf.jump(45);	index = buf.search(-10, false);
	*****************************************************/
	int jump(int numSteps, bool isUnconditionalJump = true);


	
/*****			PROTECTED SECTION			 ******/
/**************************************************/
protected:

/*****			PRIVAT SECTION			 **********/
/**************************************************/
private:
	//Переменная состояния буфера
	typedef enum BUF_STATE_ENUM
	{
		EMPTY,	//пустой
		NORMAL,	//нормальная работа буфера без переполнения
		OVF		//буфер полностью забит
	}BUF_STATE_ENUM;
	// счетчик созданных объектов
	static char m_objectCounter;

	BUF_STATE_ENUM volatile m_state = EMPTY;  //Переменная состояния буфера
	//указывает на свободную ячейку после записи в буфер
	//изменяется после каждой записи в буфер
	int volatile m_front = 0;
	//указывает на первый байт кот. нужно считать (необработанные данные)
	//изменяется при считывании с буфера
	int volatile m_end = 0;
	//длина занятой области. Считается в программе bufCalcLength
	int volatile m_len = 0;
	//максимальная длина занятой области. для анализа заполнения буфера
	int volatile m_maxLen = 0;
	int m_size = 0;						// размер буфера ( для ф-й bufClear и bufCalcLength ) т.к. sizeof(Buf)=2
	char* m_data = nullptr;		// массив данных буфера
	bool isDynamic_m_data = false;	// =1 - память была выделена динамически
	/**********   Functions   ************/
	/***************************************************************/
	// Сбрасывание флагов состояния, установка адресов на начало буфера
	void resetIndex();
	/***************************************************************/
	// Полной очистка буфера с инициализацией нулями. Указатели буфера - на начало.
	void clear();
	/***************************************************************/
	// Необходимо применять при прыжках по буферу, например после изменеия указателей буфера
	// Подсчет разницы между указателями end и front, формирование флагов буфера
	void calcLength();
};




/********************************************************
* Копирование с одного буфера в другой до указанного символа
* (не переписывается). Завершает строку \r\n в приемнике, если надо
* Вход:	*srcBufFl - буфер источника
* 			*dstBufFl - буфер приеммника
*				u08 symbol - до этого символа переписываем
*				u08 newStrFl - !=0 -вставляем в конец символ "\r\n"
* Выход: 	HAL_OK (0) - копирвоание успешно
*					HAL_ERROR (1) - копирвоание не успешно. Указатели буферов возвращены в исх.
*********************************************************/
/*u08 bufCopy(BUFFER_STRUCT* srcBufFl, BUFFER_STRUCT* dstBufFl, u08 symbol, u08 newStrFl)
{
	u16 end = srcBufFl->End;
	u16 front = dstBufFl->Front;
	while (srcBufFl->Data[srcBufFl->End] != symbol) {
		if (srcBufFl->State != Empty) {
			bufPutByte(dstBufFl, bufGetByte(srcBufFl));
		}
		else if (dstBufFl->State == Overflow) {
			// ошибка копирования. не дошли до symbol, а буфер уже пустой
			// или переполнение приемника.
			// возврат указателей, выход с ошибкой
			srcBufFl->End = end;
			dstBufFl->Front = front;
			bufCalcLength(srcBufFl);
			bufCalcLength(dstBufFl);
			return HAL_ERROR;
		}
	}
	if (newStrFl) { bufPutNewStr(dstBufFl); }
	if (dstBufFl->State == Overflow) {
		srcBufFl->End = end;
		dstBufFl->Front = front;
		bufCalcLength(srcBufFl);
		bufCalcLength(dstBufFl);
		return HAL_ERROR;
	}
	return HAL_OK;
}

/********************************************************
* Поиск символа в буфере с выборкой из буфера
* Вход:	BUFFER_STRUCT *BufFl - буфер где ищем
* 			u08 Byte - что ищем
* Выход:	res = Byte - символ найден
* 				res = 0xFF - символ не найден и буфер пустой
* 				BufFl->End на выходе указывает на байт за найденным
*********************************************************/
/*u08 bufSearchByte(BUFFER_STRUCT* BufFl, u08 Byte)
{
	u08 res = 0;
	while ((res = bufGetByte(BufFl)) != Byte && res != 0xFF);
	return res;
}



/********************************************************
* *********** Изменение указателя End буферf.	*************
* C переинициализацией остальных параметров буфера
* Вход:		BUFFER_STRUCT *BufFl - указатель на буфер где прыгать
* 				u16 newEnd - новое значение укзаателя End
* Вызов:	bufChangeEnd(&uart[ch].rxBufFl, point);
*********************************************************/
/*void bufChangeEnd(BUFFER_STRUCT* BufFl, u16 newEnd)
{
	BufFl->End = newEnd;
	bufCalcLength(BufFl);
}

/************************ (C) **END OF FILE****/


